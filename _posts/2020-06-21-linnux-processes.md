---
layout: post
title:  "Процессы в Linux"
crawlertitle: "Процессы в Linux"
summary: "Процессы Linux"
date:   2022-05-11 23:09:47 +0700
categories: posts
tags: ['Дата аналитика']
#author: Felipe
---
Для того чтобы эффективно управлять своим компьютером, вы должны доскональ­ но изучить свой сервер и работающие на нем процессы. Это поможет быстро уви­деть в системе какие-либо аномалии.

Процесс — это программа или ее потомок. При запуске программы создается но­вый процесс, в котором и работает код. Каждая программа функционирует с опре­деленными правами. Сервисы, которые активизируются при старте системы, обла­
дают правами root или nobody (без прав). Программы, которые выполняются из ко­мандной строки, наделены правами запустившего их пользователя, если не указан SUID- или SGID-бит, при котором программа имеет права владельца.

Процессы могут работать в двух режимах: фоновом (background) и центральном (foreground). Центральный режим для каждого терминала имеет только один про­цесс. Например, запустив по команде *man ls* программу для просмотра помощи, вы
не сможете выполнять другие команды, пока не выйдете из программы man. Если ни один центральный процесс в терминале не запущен, то им является интерпретатор команд.

## Cмена режима

Фоновыми процессами являются все сервисы. Они выполняют свои действия па­раллельно с вашей работой. Но и вы можете запустить любую программу в фоно­вом режиме. Для этого достаточно после указания команды через пробел поставить знак *&*. Например, выполните сейчас следующую команду:

{% highlight r %}
man ls &
{% endhighlight %}

В ответ на это вы не увидите файла помощи, а на экране появится только строка:

**[1] 2802**

После этого терминал снова готов работать, потому что центральный процесс запустил команду man is в фоновом режиме и свободен для выполнения новых ди­ректив.

В квадратных скобках пока­зан порядковый номер фонового процесса, который мы запустили. Номера будут последовательно увеличиваться. В нашем случае это первая команда, поэтомув квадратных скобках стоит единица. Номер фонового процесса формируется для каждого пользователя. Если войти в систему через второй терминал и запустить какой-либо фоновый процесс, то вы увидите примерно следующее:

**[1] 2805**

В квадратных скобках опять число 1, а вот следующее значение отличается от вы­веденного на первом терминале. Это PID (Process ID, идентификатор процесса) созданного процесса, который является уникальным для всех пользователей.

Чтобы узнать, какие процессы у вас запущены, выполните команду *jobs*. В ответ на это вы получите:

**[1] + Stopped man ls**

Здесь мы видим, что процесс с номером [1] загружен в память, и состояние коман­ды man is — Stopped (остановлен).

Какой смысл в том, что мы отправили просмотр файла помощи в фоновый режим? Я не зря выбрал эту команду, потому что в этом есть резон. Вы в любой момент можете сделать фоновый режим основным. Для этого необходимо ввести команду *fg %1*, где число 1 указывает номер вашего процесса, который вы видели в квадрат­ных скобках. Попробуйте сейчас выполнить эту команду, и перед вами откроетсязапущенная программа man, отображающая файл помощи по использованию коман­ды Is.

{% highlight r %}
fg %1 
{% endhighlight %}

Раз процесс можно сделать центральным, значит, можно поступить и наоборот. Что­бы вернуть процесс в фоновый режим, нажмите комбинацию клавиш *<Ctrl>+<Z>* — перед вами снова появится командная строка. Выполните команду *jobs*, чтобы убе­диться, что команда *man ls* все еще работает.

Если в программе есть возможность выполнять системные команды, то вместо со­четания клавиш *<Ctrl>+<Z>* можно выполнить команду *bg %1*. Число 1 — это сно­ва номер процесса.

{% highlight r %}
bg %1
{% endhighlight %}

## Остановка процессов

Чтобы прекратить работающий процесс, необходимо сделать его центральным и остановить штатными средствами. Чаще всего на экране есть подсказка, которая поможет выйти из программы. Если она отсутствует, то следует обратиться к до­кументации ИЛИ просмотреть файл ПОМОЩИ, ВЫЗВаВ: *man имя программы*.


Сервисы могут работать только в фоне и не могут быть выведены на передний план. Для того чтобы их остановить, существуют специализированные команды, которые чаще всего имеют вид:

{% highlight r %}
имясервиса stop
{% endhighlight %}

Иногда процессы зависают. Да, такие ситуации бывают и в ОС Linux. Центральный процесс может быть снят с помощью комбинации клавиш *<Ctrl>+<C>* или *<Ctrl>+<Break>*. Но этот метод срабатывает не во всех случаях и не для всех про­грамм. Если не удается завершить процесс по-хорошему, то можно поступить ина­че. Для этого существует команда kill. Чтобы отключить процесс по личному идентификатору (тому, что мы видели в квадратных скобках), используйте команду *kill* (Убить):

{% highlight r %}
kill %n
{% endhighlight %}

Параметр *n* нужно заменить номером процесса. Например, чтобы завершить работу фоновой программы *man*, нужно выполнить:

{% highlight r %}
kill %1
{% endhighlight %}

Затем сразу же запустите команду *jobs*. Вы должны увидеть на экране сообщение типа:

**[1] + Terminated man ls**

После повторного вызова команды jobs программы man больше не будет.

Если вы хотите завершить работу процесса, который запущен не вами, но вы знаете его PID, то нужно выполнить команду:

{% highlight r %}
kill n
{% endhighlight %}

Знак процента в этом случае не нужен. Тогда команда kill ищет процесс, у которо­го PID равен указанному числу n, и посылает сигнал для завершения.

## Просмотр процессов

С помощью команды *jobs* вы можете увидеть только запущенные вами процессы. Чтобы полюбопытствовать, чем в системе занимаются остальные пользователи, нужно выполнить команду *ps*.

Перед нами появится четыре колонки, которые показывают идентификатор процесса, терми­нал, на котором запущена программа, время работы и выполняемую команду.

Это далеко не полный список. Чтобы увидеть все процессы, необходимо выполнить команду ps с ключом -а. Но и это еще не будет весь перечень, потому что отобра­зятся только программы своего терминала. Если требуется полный список процес­сов, запущенных со всех терминалов, то нужно добавить ключ -х. Помимо этого, вы можете пожелать увидеть имя пользователя, под которым работает процесс, для этого добавьте ключ -u. В итоге исчерпывающую информацию можно получить, выполнив команду:

{% highlight r %}
ps -ахu
{% endhighlight %}

Результат работы будет таков:

Колонка *Stat* показывает состояние процесса. Здесь можно встретить следующие коды:

* s (Sleeping) — спящий, это нормальное состояние для сервисов, которые просы­
паются только на редкие запросы клиентов;
* r (Runnable) — исполняемый в текущий момент;
* т (Traced or Stopped) — в состоянии отладки или остановлен;
* z (Zombied) — зависший. Такие процессы можно смело «убивать»;
* w — не имеет резидентных страниц;
* < — обладает высоким приоритетом;
* N — имеет низкий приоритет.

Это основные состояния, которые вы можете увидеть у процессов в своей системе.

Если в колонке *Tty* стоит вопросительный знак, то это означает, что процесс запу­щен еще на этапе загрузки системы и не принадлежит какому-либо терминалу.

Здесь показан всего лишь небольшой фрагмент файла. В реально работающей сис­теме процессов очень много, и даже при минимальном количестве запущенных сервисов может не хватить одного экрана для отображения их всех. Я люблю со­хранять результат работы в текстовый файл, а потом спокойно изучать его в любом редакторе. Для этого я выполняю команду:

{% highlight r %}
ps -ахu >> ps.txt
{% endhighlight %}

Чтобы увидеть, чем в настоящий момент занимаются другие пользователи, можно выполнить команду *w*.

{% highlight r %}
w
{% endhighlight %}

Очень удобно опре­делять по списку, когда пользователь вошел в систему (колонка *login@* ) и что он делает в настоящее время (колонка *what*).

Посмотрите на столбцы *Jcpu* и *Pcpu* — по ним можно оценить загрузку системы. Если ваш компьютер начал работать слишком медленно, то эти столбцы покажут, какой процесс отнимает много процессорного времени.

Команда ps выводит статическую информацию. Для наблюдения за нагрузкой сис­темы удобнее использовать команду top. Она отображает список процессов, отсор­тированный по убыванию в зависимости от нагрузки. Здесь вы мржете увидеть, какой сервис или программа отнимают драгоценные ресурсы и не дают нормально работать с компьютером.

## «Зомби»: поиск и устранение

Итак, у меня скрипты работают в постоянном режиме и создают новые процессы (дочерние), которые выполняют какие-то работы. Иногда бывает так, что дочерний процесс завершил свою работу, а родительский не видит этого и считает, что дочерний все еще работает. В системе образуются как бы «зомби» — которые не видят, что «тело уже умерло», и продолжают «дышать» и использовать ресурсы.

У меня все родительские процессы записывают себя в журнал в основном скрипте. Я знаю их ID, но не знаю, какой именно из дочерних завис или превратился в «зом­би». Команда *ps* далеко не всегда показывает правильно такие проблемы.

В таких случаях я выполняю команду:

{% highlight r %}
ps -al
{% endhighlight %}

Эта команда выводит подробную информацию о выполняющихся сейчас процессах:

Самыми важными здесь являются вторая и третья колонки: PID (process ID) и PPID (parent process ID). Во второй строке в колонке PPID записано 702. Это значит, что процесс в этой строке является дочерним для процесса с PID, равным 702. Этот
процесс можно увидеть в первой строке. Третья строка является дочерней для вто­рой. То есть третий процесс — самый низший в иерархии.

Когда процессов много, то сразу так иерархию построить не получится. В этом случае можно фильтровать вывод с помощью следующей команды:

{% highlight r %}
ps -al | grep ХХХ
{% endhighlight %}

Здесь вы видите две команды, разделенные вертикальной чертой. Первая команда слева:

{% highlight r %}
ps -al
{% endhighlight %}

показывает подробную информацию о всех процессах. Вторая:

{% highlight r %}
grep
{% endhighlight %}

фильтрует вывод. И при этом показывает на экране только те строки, в которых есть текст ххх. В качестве этого ххх нужно указать ID родительского процесса.

Таким путем я иду от родительского процесса к дочерним и ищу самый последний из них. Когда нахожу последний, его и «убиваю» командой *kill*. Если не помогает, то «убиваю» предпоследний. Очень часто «убийство» последнего процесса не по­
могает, потому что он обычно уже реально не работает, а просто висит как фантом. А вот когда я «убиваю» предпоследний, то это видит вся цепочка дерева иерархии процессов.