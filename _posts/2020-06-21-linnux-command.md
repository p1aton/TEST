---
layout: post
title:  "Основные команды Linux"
crawlertitle: "Основные базовые команды Linux"
summary: "Команды Linux"
date:   2020-06-22 23:09:47 +0700
categories: posts
tags: ['Дата аналитика']
#author: Felipe
---

Терминал в Линукс обладает большим списком полезных консольных команд, которые пригодятся пользователям, решил сделать шпаргалку по базовым командам для терминала, которые позволят создавать директории, удалять файлы, просматривать, редактировать и многие другие...


# Файловые команды
{% highlight r %}
ls – список файлов и каталогов
ls -al – форматированный список со скрытыми каталогами и файлами
cd dir – сменить директорию на dir
cd – сменить на домашний каталог
pwd – показать текущий каталог
mkdir dir – создать каталог dir
rm file – удалить file
rm -r dir – удалить каталог dir
rm -f file – удалить форсированно file
rm -rf dir – удалить форсированно каталог dir
cp file1 file2 – скопировать file1 в file2
cp -r dir1 dir2 – скопировать dir1 в dir2; создаст каталог dir2, если он не существует
mv file1 file2 – переименовать или переместить file1 в file2. если file2 существующий каталог - переместить file1 в каталог file2
ln -s file link – создать символическую ссылку link к файлу file
touch file – создать file
cat > file – направить стандартный ввод в file
more file – вывести содержимое file
head file – вывести первые 10 строк file
tail file – вывести последние 10 строк file
tail -f file – вывести содержимое file по мере роста, начинает с последних 10 строк
xdg-open ~/.vscode/extensions - открыть папку
{% endhighlight %}

# Управление процессами
{% highlight r %}
ps – вывести ваши текущие активные процессы
top – показать все запущенные процессы
kill pid – убить процесс с id pid
killall proc – убить все процессы с именем proc
bg – список остановленных и фоновых задач; продолжить выполнение остановленной задачи в фоне
fg – выносит на передний план последние задачи
fg n – вынести задачу n на передний план
Права доступа на файлы
chmod octal file – сменить права file на octal, раздельно для пользователя, группы и для всех добавлением:
4 – чтение (r)
2 – запись (w)
1 – исполнение (x)

Примеры:
chmod 777 – чтение, запись, исполнение для всех
chmod 755 – rwx для владельца, rx для группы и остальных.
Дополнительные опции: man chmod.
{% endhighlight %}

# SSH
{% highlight r %}
ssh user@host – подключится к host как user
ssh -p port user@host – подключится к host на порт port как user
ssh-copy-id user@host – добавить ваш ключ на host для user чтобы включить логин без пароля и по ключам
{% endhighlight %}

# Поиск
{% highlight r %}
grep pattern files – искать pattern в files
grep -r pattern dir – искать рекурсивно pattern в dir
command | grep pattern – искать pattern в выводе command
locate file – найти все файлы с именем file
find -regex ./.*\.js$ - поиск всех файлов js
grep -E -o '5[HJK][1-9A-HJ-NP-Za-km-z]{49}' test.txt > goal.txt - поиск по регулярному выражению
{% endhighlight %}

# Системная информация
{% highlight r %}
date – вывести текущую дату и время
cal – вывести календарь на текущий месяц
uptime – показать текущий аптайм
w – показать пользователей онлайн
whoami – имя, под которым вы залогинены
finger user – показать информацию о user
uname -a – показать информацию о ядре
cat /proc/cpuinfo – информация ЦПУ
cat /proc/meminfo – информация о памяти
man command – показать мануал для command
df – показать инф. о использовании дисков
du – вывести “вес” текущего каталога
free – использование памяти и swap
whereis app – возможное расположение программы app
which app – какая app будет запущена по умолчанию
{% endhighlight %}

# Архивация
{% highlight r %}
tar cf file.tar files – создать tar-архив с именем file.tar содержащий files
tar xf file.tar – распаковать file.tar
tar czf file.tar.gz files – создать архив tar с сжатием Gzip
tar xzf file.tar.gz – распаковать tar с Gzip
tar cjf file.tar.bz2 – создать архив tar с сжатием Bzip2
tar xjf file.tar.bz2 – распаковать tar с Bzip2
gzip file – сжать file и переименовать в file.gz
gzip -d file.gz – разжать file.gz в file
{% endhighlight %}

# Сеть
{% highlight r %}
ping host – пропинговать host и вывести результат
whois domain – получить информацию whois для domain
dig domain – получить DNS информацию domain
dig -x host – реверсивно искать host
wget file – скачать file
wget -c file – продолжить остановленную закачку
{% endhighlight %}

# Установка пакетов
{% highlight r %}
Установка из исходников:
./configure
make
make install
dpkg -i pkg.deb – установить пакет (Debian)
rpm -Uvh pkg.rpm – установить пакет (RPM)
{% endhighlight %}

# Клавиатурные сочетания
{% highlight r %}
Ctrl+C – завершить текущую команду
Ctrl+Z – остановить текущую команду, продолжть с fg на переднем плане или bg в фоне
Ctrl+D – разлогиниться, тоже самое, что и exit
Ctrl+W – удалить одно слово в текущей строке
Ctrl+U – удалить строку
!! - повторить последнюю команду
exit – разлогиниться
{% endhighlight %}

# Специальные символы
{% highlight r %}
. текущая директория
.. директория на уровень выше
~ домашняя директория
* любое количество любых символов
? ровно один любой символ
{% endhighlight %}


# Необходимый минимум команд

Итак, запоми­най самые важ­ные коман­ды, если еще не зна­ешь их:
    {% highlight r %}
    * man — чуть ли не самая важ­ная коман­да — она отоб­ража­ет справ­ку о коман­де, наз­вание которой ты напишешь сле­дом;
    * ls (от сло­ва list, спи­сок) — перечис­лить все фай­лы в текущей дирек­тории, ана­лог вин­довой коман­ды dir. Самые важ­ные клю­чи: -a (all) — показы­вать скры­тые фай­лы, -l (long) — показы­вать под­робнос­ти, -h (human) — показы­вать раз­меры в «челове­чес­ких» еди­ницах, а не в бай­тах. Мож­но писать все клю­чи сра­зу: ls -lha;
    * cd (change directory) — сме­нить дирек­торию. Даль­ше мож­но ука­зать пап­ку, в которую ты хочешь перей­ти;
    * pwd (print working directory) — узнать текущий путь;
    * cp (copy) — ско­пиро­вать файл. Даль­ше нуж­но ука­зать, что и куда копиро­вать;
    * mv (move) — перемес­тить файл. Тоже ука­зыва­ем какой, затем — куда;
    * rm (remove) — сте­реть файл. Если сти­раешь каталог, ука­зывай опцию -r (recursive), что­бы сте­реть все под­катало­ги внут­ри, под­катало­ги внут­ри них и так далее;
    * chmod и chown — поменять пра­ва на файл или вла­дель­ца фай­ла;
    * cat (concatenate) — при­дума­на, что­бы объ­еди­нять фай­лы, но час­то исполь­зует­ся, что­бы все­го лишь вывес­ти содер­жимое тек­сто­вого фай­ла. Прос­то напиши его наз­вание пос­ле cat;
    * less — если файл длин­ный, то его удоб­но прок­ручивать. Для это­го и при­дума­на коман­да less;
    head и tail — с опци­ей -n число показы­вают сколь­ко‑то строк от начала (head) или кон­ца (tail) ука­зан­ного фай­ла;
    * grep — поиск в стро­ке по подс­тро­ке или регуляр­ному выраже­нию;
    * find — поиск фай­лов;
    * mkdir (make directory) — соз­дание дирек­тории;
    * touch — соз­дание пус­того фай­ла. Прос­то ука­жи его наз­вание;
    * sudo — выпол­нить сле­дующую далее коман­ду от име­ни супер­поль­зовате­ля;
    * df (disk free) — пос­мотреть, сколь­ко на дис­ках сво­бод­ного мес­та. Рекомен­дую писать df -h по ана­логии с ls -h;
    * du (disk usage) — узнать, сколь­ко занима­ет каталог. Тоже есть опция -h;
    * ps (processes) — пос­мотреть спи­сок запущен­ных тобой про­цес­сов и их иден­тифика­торы;
    * kill и иден­тифика­тор — завер­шить какой‑то про­цесс.
    {% endhighlight %}
Нес­коль­ко важ­ных сетевых команд:
    {% highlight r %}
    * ping — попин­говать узел;
    * nslookup — узнать информа­цию об узле;
    * traceroute — прос­ледить путь пакетов до узла;
    * netstat — информа­ция об откры­тых пор­тах и соеди­нени­ях;
    * whois — информа­ция о регис­тра­ции домена.
    {% endhighlight %}
По­мимо это­го, в Linux обыч­но есть нес­коль­ко ути­лит, которые силь­но облегчат тебе жизнь. Если их нет, то сто­ит их уста­новить:
    {% highlight r %}
    * git — популяр­ней­шая сис­тема кон­тро­ля вер­сий, как и ядро Linux, соз­данная Линусом Тор­валь­дсом;
    * nano — прос­тей­ший тек­сто­вый редак­тор, работа­ющий в тер­минале;
    * unzip и unrar — думаю, ты догады­ваешь­ся, зачем они нуж­ны;
    * curl нужен для веб‑зап­росов;
    * wget — для ска­чива­ния боль­ших фай­лов;
    * htop — показы­вает уро­вень заг­рузки сис­темы и спи­сок про­цес­сов.
    * [bashtop](https://github.com/aristocratos/bashtop) — дашборд показы­вает уро­вень заг­рузки сис­темы и спи­сок про­цес­сов
    {% endhighlight %}
Важ­но: вый­ти из прог­рамм, которые не зак­рыва­ются сами, обыч­но мож­но, нажав Q. Прер­вать работу — Ctrl-C. А что­бы вый­ти из vim, если ты его открыл слу­чай­но, набери пос­ледова­тель­ность :q! и наж­ми Enter.

В домаш­нем катало­ге поль­зовате­ля хра­нит­ся нес­коль­ко скры­тых фай­лов, которые могут быть очень полез­ны при работе в Linux. Что­бы прос­мотреть скры­тые фай­лы в текущем катало­ге, исполь­зуй кон­соль­ную коман­ду ls -a или поковы­ряй­ся в меню фай­лового менед­жера: нап­ример, в Nautilus пункт «Показать скры­тые фай­лы» пря­чет­ся в меню «Вид». Обра­ти вни­мание на сле­дующие скры­тые фай­лы:
    {% highlight r %}
    * .bash_profile — содер­жит информа­цию о поль­зователь­ском окру­жении и запус­каемых при авто­риза­ции поль­зовате­ля прог­раммах. В некото­рых дис­три­бути­вах, осно­ван­ных на Debian, дан­ного фай­ла по умол­чанию не сущес­тву­ет, но ты можешь соз­дать его самос­тоятель­но;
    * .bash_login — этот файл исполня­ется, если отсутс­тву­ет .bash_profile, и выпол­няет схо­жую фун­кцию. Это­го фай­ла не сущес­тву­ет по умол­чанию ни в дис­три­бути­ве Debian, ни в дис­три­бути­ве Red Hat;
    * .profile — выпол­няет­ся при отсутс­твии .bash_profile и .bash_login;
    * .bash_logout — сце­нарий, который выпол­няет­ся авто­мати­чес­ки при завер­шении работы коман­дной обо­лоч­ки;
    * .bash_history — хра­нит информа­цию обо всех коман­дах, наб­ранных в bash;
    * .ssh — каталог, в котором хра­нят­ся клю­чи шиф­рования для под­клю­чения по SSH;
    * .bashrc — сце­нарий, который обыч­но нас­тра­ивает­ся дру­гими сце­нари­ями для сво­их собс­твен­ных нужд — нап­ример, запус­ка демонов или обра­бот­ки каких‑либо команд.
    {% endhighlight %}







[Справочник основных команд Linux с примерами](http://zabrosov.ru/)  
[Команды Linux: расширенный справочник команд Unix / Linux / PuTTY SSH](https://putty.org.ru/articles/unix-linux-ref.html)  
[Основные команды Linux: справочник команд Linux](https://otus.ru/nest/post/830/)  


[Oh My Zsh](https://ohmyz.sh/#install)





<!---
Независимо от того, случайно ли вы зафиксировали изменения или просто поняли, что ваш предыдущий зафиксированный код - это не то, что вам нужно, часто вам потребуется отменить предыдущий коммит в Git. В этой статье рассмотрим несколько способов отменить ваши коммиты, в зависимости от вашего варианта использования.

1. Что значит вернуться или откатиться: просто посмотреть, изменить содержимое рабочей области, изменить историю Git?
2. Что именно откатить: рабочую область (worktree), индекс (область подготовки коммита, staging area), текущую ветку, удаленную ветку?
3. К какой позиции откатить: к индексу, к последнему коммиту, к произвольному коммиту?
Обозначим начальную ситуацию на следующей схеме:

Обозначим начальную ситуацию на следующей схеме:

{% highlight Ruby %}

          (i) (wt)
A - B - C - D - ? - ?
            ↑
          master
          (HEAD)
{% endhighlight %}

A, B, C, D — коммиты в ветке master.
(HEAD) — местоположение указателя HEAD.
(i) — состояние индекса Git. Если совпадает c (HEAD) - пуст. Если нет - содержит изменения, подготовленные к следующему коммиту.
(wt) — состояние рабочей области проекта (working tree). Если совпадает с (i) — нет неиндексированных изменений, если не совпадает — есть изменения.
↑ обозначает коммит, на который указывает определенная ветка или указатель.

Вот решения, в зависимости от задачи:

#### 1. Временно переключиться на другой коммит

Если вам нужно просто переключиться на другой коммит, чтобы, например, посмотреть на его содержимое, достаточно команды git checkout:

{% highlight Ruby %}
git checkout aaaaaa

 (wt)
 (i)
  A - B - C - D
  ↑           ↑
(HEAD)    master
{% endhighlight %}

Сейчас репозиторий находится в состоянии «detached HEAD». Чтобы переключиться обратно, используйте имя ветки (например, master):

{% highlight Ruby %}
git checkout master
{% endhighlight %}

#### 2. Переключиться на коммит и продолжить работу с него

Если вы хотите продолжить работу с другого коммита, вам понадобится новая ветка. Можно переключиться и создать ее одной командой:

{% highlight Ruby %}
git checkout -b имя-новой-ветки aaaaaa

 (wt)
 (i)
  A - B - C - D
  ↑           ↑
 new       master
(HEAD)
{% endhighlight %}

#### 3. Удалить изменения в рабочей области и вернуть ее к состоянию как при последнем коммите.

Начальное состояние:

{% highlight Ruby %}
       (i) (wt)
A - B - C - D - ? - ?
            ↑
          master
          (HEAD)
{% endhighlight %}

#### 3.1 Безопасно — с помощью кармана (stash)

#### 3.1.1 Только неиндексированные

Можно удалить прикарманить только те изменения, которые еще не были индексированы (командой add):

{% highlight Ruby %}
git stash save --keep-index
{% endhighlight %}

Конечное состояние:

{% highlight Ruby %}
 (wt)
               (i)       
A - B - C - D - ?         ?
            ↑             ↑
          master      stash{0}
          (HEAD)
{% endhighlight %}

#### 3.1.2 Индексированные и нет

Эта команда отменяет все индексированные и неиндексированные изменения в рабочей области, сохраняя их в карман (stash).

{% highlight Ruby %}
git stash save
{% endhighlight %}

Конечное состояние:

{% highlight Ruby %}
  (wt)
           (i)           
A - B - C - D             ?
            ↑             ↑
          master      stash{0}
          (HEAD)
{% endhighlight %}

Восстановление несохраненных изменений: легко и просто.

{% highlight Ruby %}
git stash apply
{% endhighlight %}

Если stash совсем не нужен, его можно удалить.

{% highlight Ruby %}
# удалить последнюю запись кармана
git stash drop
{% endhighlight %}

https://regexr.com/5g233

После этого восстановить изменения всё ещё можно, но сложнее: <a href='https://stackoverflow.com/q/89332/2790048'>How to recover a dropped stash in Git?</a> ?

#### 3.2 Опасный способ

<b>Осторожно!</b> Эта команда безвозвратно удаляет несохраненные текущие изменения из рабочей области и из индекса Если они вам все-таки нужны, воспользуйтесь git stash.

Восстановление несохраненных изменений: неиндексированные потеряны полностью, но <a href='https://ru.stackoverflow.com/a/424384/181472'>вы можете восстановить то, что было проиндексировано</a>.

Здесь мы будем использовать git reset --hard

Выполняем:

{% highlight Ruby %}
git reset --hard HEAD
{% endhighlight %}

Конечное состояние:

{% highlight Ruby %}
      (wt)
           (i)
A - B - C - D - х - х
            ↑
          master
          (HEAD)
{% endhighlight %}

#### 4. Перейти к более раннему коммиту в текущей ветке и удалить из нее все последующие (неопубликованные)

<b>Осторожно!</b>Эта команда переписывает историю Git-репозитория. Если вы уже опубликовали <a href='https://ru.stackoverflow.com/tags/git-push/info'>(git push) </a>свои изменения, то этот способ использовать нельзя <a href='https://ru.stackoverflow.com/questions/429512/'>(см. почему)</a>. Используйте вариант из пункта 5 <a href='https://ru.stackoverflow.com/tags/git-revert/info'>(git revert)</a>.

#### 4.1 При этом сохранить изменения в индекс репозитория:

{% highlight Ruby %}
git reset --soft bbbbbb
{% endhighlight %}

После этого индекс репозитория будет содержать все изменения от cccccc до dddddd. Теперь вы можете сделать новый коммит (или несколько) на основе этих изменений.

{% highlight Ruby %}
           (wt)
           (i)
A - B - C - D 
    ↑
  master
  (HEAD)
{% endhighlight %}

#### 4.2 Сохранить изменения в рабочей области, но не в индексе.

{% highlight Ruby %}
git reset bbbbbb
{% endhighlight %}

Эта команда просто перемещает указатель ветки, но не отражает изменения в индексе (он будет пустым).

{% highlight Ruby %}
 (i)     (wt)
A - B - C - D 
    ↑
  master
  (HEAD)
{% endhighlight %}

#### 4.3 Просто выбросить изменения.

<b>Осторожно!</b> Эта команда безвозвратно удаляет несохраненные текущие изменения. Если удаляемые коммиты не принадлежат никакой другой ветке, то они тоже будут потеряны.

<b>Восстановление коммитов:</b> Используйте <a href='https://ru.stackoverflow.com/tags/git-reflog/info'>git reflog</a> и <a href='https://ru.stackoverflow.com/questions/232455/'>этот вопрос</a>этот вопрос чтобы найти и восстановить коммиты; иначе сборщик мусора удалит их безвозвратно через некоторое время.

Восстановление несохраненных изменений: неиндексированные потеряны полностью, но <a href='https://ru.stackoverflow.com/a/424384/181472'>вы можете восстановить то, что было проиндексировано</a>вы можете восстановить то, что было проиндексировано.

Начальное состояние:

{% highlight Ruby %}
   (i) (wt)
A - B - C - D - ? -  ?
            ↑
          master
          (HEAD)
{% endhighlight %}

Выполняем:

{% highlight Ruby %}
git reset --hard bbbbbb
{% endhighlight %}

Конечное состояние:

{% highlight Ruby %}
 (wt)
   (i)
A - B - C - D - х - х
    ↑
  master
  (HEAD)
{% endhighlight %}

#### 

5. Отменить уже опубликованные коммиты с помощью новых коммитов
Воспользуйтесь командой <a href='https://ru.stackoverflow.com/tags/git-revert/info'>git revert</a>. Она создает новые коммиты, по одному на каждый отменяемый коммит. Таким образом, если нужно отменить все коммиты после aaaaaa:

{% highlight Ruby %}
 # можно перечислить отменяемые коммиты
git revert bbbbbb cccccc dddddd

# можно задать диапазон от более раннего к более позднему (новому)
git revert bbbbbb..dddddd

# либо в относительных ссылках
git revert HEAD~2..HEAD

# можно отменить коммит слияния, указывая явным образом номер предка (в нашем примере таких нет):
git revert -m 1 abcdef

# после этого подтвердите изменения:
git commit -m'детальное описание, что и почему сделано'
{% endhighlight %}

<b>Восстановление:</b> Если revert-коммит оказался ошибочным, <a href='https://ru.stackoverflow.com/a/433111/181472'>используйте этот ответ</a>.

--->