---
layout: post
title:  "Регулярные выражения Python"
crawlertitle: "Регулярные выражения в Python"
summary: "RegEx Python"
date:   2022-05-31 23:09:48 +0700
categories: posts
tags: ['Веб аналитика']
#author: Felipe
---


Регулярные выражения (RegEx) — это специальная последовательность символов, которая использует шаблон поиска для поиска строки или набора строк. Он может определять наличие или отсутствие текста путем сопоставления с определенным шаблоном, а также может разбивать шаблон на один или несколько подшаблонов. Python предоставляет модуль re, который поддерживает использование регулярных выражений в Python. Его основная функция — предлагать поиск, где он принимает регулярное выражение и строку. Он либо возвращает первое совпадение, либо ничего.


# Сырые строки / raw strings

Чтобы строка стала «сырой», перед ней необходимо поставить символ r в любом регистре:

{% highlight r %}
common_string = 'C:\file.txt'
raw_string = r'C:\file.txt'
{% endhighlight %}

В такой строке отключается экранирование. Это значит, что обратный слеш считается самостоятельным символом. Основное применение сырых строк – работа с регулярными выражениями.

Можно использовать несколько префиксов сразу. Например, вот так:

{% highlight r %}
raw_f_string = rf'C:\file.txt'
f_raw_string = fr'C:\file.txt'
{% endhighlight %}

# Экранирование в регулярных выражениях

В регулярных выражениях также есть экранирование. Каждое регулярное выражение, которое используется в коде, компилируется интерпретатором, и заменяет управляющие последовательности на другие символы. Если нам нужно использовать какой-то спецсимвол как простой текст, то достаточно поставить перед ним \. Это работает со всеми спецсимволами!

# Полезные строки

Если для тестирования регулярных выражений вам понадобится английский/русский алфавит, цифры, или символы - можете воспользоваться следующей строчкой:

{% highlight r %}
<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}~абвгдеёжзийклмнопрстуфхцчшщъыьэюяАБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ !"#$%&\'()*+,-./0123456789:;
{% endhighlight %}

С помощью неё можно наглядно увидеть как работает какой-либо спецсимвол или шаблон. Для тестирования примитивных выражений будет очень полезна.

# Синтаксис регулярных выражений

У регулярных выражений существует свой необычный синтаксис. Мы пройдём все темы по порядку. Начнём с текста как регулярного выражения.

# Текст как регулярное выражение

Начнём с самых лёгких регулярных выражений - текстовых. Простая строка r"Привет" может быть использована как регулярное выражение:

{% highlight r %}
r"Привет"
{% endhighlight %}

# Использование квадратных скобок

1) Если мы хотим заменить несколько символов, мы можем использовать такой синтаксис с квадратными скобками:

{% highlight r %}
r'[cr1]' #Найдёт c, r, и 1
r'[cr]at' #Найдёт слова cat и rat
r'[12]7[56]' #Найдёт 175, 176, 275, 276
{% endhighlight %}

От перестановки символов смысл не меняется:

{% highlight r %}
r'[cr1]' #Найдёт c, r, и 1
r'[rc1]' #Найдёт c, r, и 1
r'[1cr]' #Найдёт c, r, и 1
r'[1rc]' #Найдёт c, r, и 1
r'[c1r]' #Найдёт c, r, и 1
r'[r1c]' #Найдёт c, r, и 1
#Все регулярные выражения сверху выдают один и тот же результат
{% endhighlight %}

2) Если мы хотим исключить какие-либо символы, мы можем использовать скобки так:

{% highlight r %}
r'[^12]' #Найдёт всё, кроме 1 и 2
r'[^12]7' #Найдёт всё, кроме 17 и 27
{% endhighlight %}

Достаточно перед символами, которые мы хотим исключить, прописать символ ^.

3) Регулярное выражение в скобках можно сократить вот так:

{% highlight r %}
r'[0-9]' #То же самое, что и [0123456789]
r'[a-z]' #То же самое, что и [abcdefghijklmnopqrstuvwxyz]
r'[A-Z]' #То же самое, что и [ABCDEFGHIJKLMNOPQRSTUVWXYZ]
r'[а-я]' #То же самое, что и [абвгдежзийклмнопрстуфхцчшщъыьэюя]
r'[А-Я]' #То же самое, что и [АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ]
{% endhighlight %}

Можно получать неполный алфавит, или не все цифры:

{% highlight r %}
r'[4-7]' #То же самое, что и [4567]
r'[x-z]' #То же самое, что и [xyz]
r'[B-D]' #То же самое, что и [BCD]
r'[а-ж]' #То же самое, что и [абвгдеж]
r'[П-Т]' #То же самое, что и [ПРСТ]
r'[6-D]' #То же самое, что и [6789ABCD]
{% endhighlight %}

А также совмещать синтаксис:

{% highlight r %}
r'[4-7qwerty]' #То же самое, что и [qwerty4567]
r'[23x-z1]' #То же самое, что и [xyz123]
r'[B-DF]' #То же самое, что и [BCDF]
{% endhighlight %}

4) Исключение символов можно тоже сократить:

{% highlight r %}
r'[^0-9]' #То же самое, что и [^0123456789]
r'[^a-z]' #То же самое, что и [^abcdefghijklmnopqrstuvwxyz]
r'[^A-Z]' #То же самое, что и [^ABCDEFGHIJKLMNOPQRSTUVWXYZ]
r'[^а-я]' #То же самое, что и [^абвгдежзийклмнопрстуфхцчшщъыьэюя]
r'[^А-Я]' #То же самое, что и [^АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ]
{% endhighlight %}

Можно исключать неполный алфавит, или не все цифры:

{% highlight r %}
r'[^4-7]' #То же самое, что и [^4567]
r'[^x-z]' #То же самое, что и [^xyz]
r'[^B-D]' #То же самое, что и [^BCD]
r'[^а-ж]' #То же самое, что и [^абвгдеж]
r'[^П-Т]' #То же самое, что и [^ПРСТ]
r'[^6-D]' #То же самое, что и [^6789ABCD]
{% endhighlight %}

Ну и совмещать:

{% highlight r %}
r'[^4-7qwerty]' #То же самое, что и [^qwerty4567]
r'[^23x-z1]' #То же самое, что и [^xyz123]
r'[^B-DF]' #То же самое, что и [^BCDF]
{% endhighlight %}

5) Можно использовать столько сокращений, сколько мы захотим:

{% highlight r %}
r'[a-zA-Z0-9]' #То же самое, что [abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789]
r'[^э-я1-3]' #То же самое, что и [^эюя123]
{% endhighlight %}

Обратите внимание, что шаблон [а-яА-Я] не захватывает буквы ё и Ё.

# Шаблоны

В регулярных выражения можно использовать специальные шаблоны, которые могут соответствовать как одному, так и нескольким символам.

<table>
	<tbody>
    <tr>
			<th>Шаблон</th>
			<th>Соответствие</th>
		</tr>
		<tr>
			<td>\n</td>
			<td>Новая строка</td>
		</tr>
		<tr>
			<td>.</td>
			<td>Любой символ, кроме символа новой строки. Если flag=re.DOTALL - любой символ.</td>
		</tr>
		<tr>
			<td>\s</td>
			<td>Любой символ пробела, табуляции или новой строки.</td>
		</tr>
		<tr>
			<td>\S</td>
			<td>Любой символ, кроме пробела, табуляции или новой строки.</td>
		</tr>
		<tr>
			<td>\d</td>
			<td>Любая цифра. Эквивалентно [0-9]</td>
		</tr>
		<tr>
			<td>\D</td>
			<td>Любой символ, кроме цифр. Эквивалентно [^0-9]</td>
		</tr>
		<tr>
			<td>\w</td>
			<td>Любая буква, цифра, или _.</td>
		</tr>
		<tr>
			<td>\W</td>
			<td>Любой символ, кроме букв, цифр, и _.</td>
		</tr>
		<tr>
			<td>\b</td>
			<td>Символ между символом, совпадающим с \w, и символом, не совпадающим с \w в любом порядке.</td>
		</tr>
		<tr>
			<td>\B</td>
			<td>Символ между двумя символами, совпадающими с \w или \W.</td>
		</tr>
		<tr>
			<td>\A</td>
			<td>Начало всего текста</td>
		</tr>
		<tr>
			<td>\Z</td>
			<td>Конец всего текста</td>
		</tr>
		<tr>
			<td>^</td>
			<td>Начало всего текста или начало строчки текста, если flag=re.MULTILINE</td>
		</tr>
		<tr>
			<td>$</td>
			<td>Конец всего текста или конец строчки текста, если flag=re.MULTILINE</td>
		</tr>
		<tr>
			<td>\r</td>
			<td>carriage return или CR, символ Юникода U+2185.</td>
		</tr>
		<tr>
			<td>\t</td>
			<td>Tab символ</td>
		</tr>
		<tr>
			<td>\0</td>
			<td>null, символ Юникода U+2400.</td>
		</tr>
		<tr>
			<td>\v</td>
			<td>Вертикальный пробел в Юникоде</td>
		</tr>
		<tr>
			<td>\xYY</td>
			<td>8-битный символ с заданным шестнадцатеричным значением. [Таблица юникода](https://unicode-table.com/en/). Например \x2A находит символ *.</td>
		</tr>
		<tr>
			<td>\ddd</td>
			<td>8-битный символ с заданным восьмеричным значением. [Таблица UTF-8](https://www.utf8-chartable.de/unicode-utf8-table.pl?utf8=oct)</td>
		</tr>
		<tr>
			<td>[\b]</td>
			<td>Символ backspace или BS. В скобках, т.к. \b уже занято другим спецсимволом.</td>
		</tr>
		<tr>
			<td>\f</td>
			<td>Символ разрыва страницы.</td>
		</tr>
	</tbody>
</table>

# Жадные квантификаторы

Очень часто, когда нужно использовать несколько шаблонов подряд, приходится их писать друг за другом. Например, если мы хотим найти 3 цифры подряд мы напишем:

{% highlight r %}
r'\d\d\d'
{% endhighlight %}

Но теперь, мы можем сократить эту запись вот так, используя квантификаторы:

{% highlight r %}
r'\d{3}'
{% endhighlight %}

## Что же такое квантификатор?

Квантификатор - конструкция, которая позволяет указывать количество повторений.

<table>
	<tbody>
    <tr>
			<th>Квантификатор</th>
			<th>Использование</th>
		</tr>
		<tr>
			<td>{n}</td>
			<td>Ровно n повторений</td>
		</tr>
		<tr>
			<td>{m,n}</td>
			<td>От m до n повторений.</td>
		</tr>
		<tr>
			<td>{m,}</td>
			<td>Не менее m повторений</td>
		</tr>
		<tr>
			<td>{,n}</td>
			<td>Не более n повторений</td>
		</tr>
		<tr>
			<td>?</td>
			<td>Ноль или одно повторение. То же, что и {0,1}</td>
		</tr>
		<tr>
			<td>*</td>
			<td>Ноль или более повторений. То же, что и {0,}</td>
		</tr>
		<tr>
			<td>+</td>
			<td>Одно или более повторений. То же, что и {1,}</td>
		</tr>
	</tbody>
</table>

Интересные факты о квантификаторах:

* В каждом квантификаторе учитываются и начало, и конец отрезка.
* Каждый квантификатор по умолчанию - жадный. Жадные квантификаторы - такие квантификаторы, которые пытаются захватить как можно больше символов.

# Ленивые квантификаторы

Все квантификаторы - по умолчанию жадные. Они пытаются захватить максимальное количество символов.

{% highlight r %}
{m,n}
{,n}
{m,}
*
+
?
{% endhighlight %}

Если после квантификатора поставить знак ?, то можно его сделать ленивым. Тогда он будет захватывать минимальное количество символов.

Ленивые квантификаторы

{% highlight r %}
{m,n}? - от m до n
{,n}? - до n
{m,}? - от m
*? - от 0
+? - от 1
?? - от 0 до 1
Каждый из этих квантификаторов будет пытаться захватить как можно меньше символов.
{% endhighlight %}

Обратите внимение, что жадность меняет работу всех квантификаторов, кроме квантификатора {n}. Но это и логично, так как в любом случае он будет искать нужную последовательность n раз, независимо от его жадности. Квантификатор {n} будет равносилен квантификатору {n}?, правда в последнем нет никакого смысла.

# Группирующие скобки

Если шаблон регулярного выражения обернуть в  круглые скобки - мы сгруппируем его. Такие группы создаются для получения дополнительной информации о них.

Позже мы к ним снова вернёмся и пройдём их работу в самом Python. Но сейчас нужно изучить сам синтаксис.

<table>
	<tbody>
    <tr>
			<th>Синтаксис</th>
			<th>Использование</th>
		</tr>
		<tr>
			<td>(regex)</td>
			<td>Обыкновенная скобочная группа. Захватывает символы, о которых можно будет получить более подробную информацию.</td>
		</tr>
		<tr>
			<td>(?P\<name\>regex)</td>
			<td>Обычная скобочная группа, но вместо номера ей будет присвоено имя name.</td>
		</tr>
		<tr>
			<td>(?P\<name\>regex)(?P=name)</td>
			<td>Скобочная группа с именем позволяет к ней обращаться и искать такой же текст, который она захватила.</td>
		</tr>
	</tbody>
</table>

Эти же группы в реальных примерах:

* 1) Обычная группа ([a-z]{4})
* 2) Та же группа, только уже именованная (?P<name>[a-z]{4}). Теперь мы можем получить её в Python не по номеру, а по имени. 
* 3) Снова именованная группа, но мы получаем текст, который она захватила ранее благодаря синтаксису (?P<name>[a-z]{4})(?P=name)

## Ссылки на нумерованные группы

Ссылаться можно не только на именованные группы, но и на обычные. Для этого достаточно использовать синтаксис \1, \2, \3, ... и так далее. Цифра после слеша означает номер группы, к которой вы обращаетесь.

Повторяем регулярное выражение, но уже без именованных групп ([a-z]{4})\1

# Скобочные выражения

Если в группе, после открывающейся круглой скобки поставить специальные символы - можно создать особое скобочное выражение, которое добавит новую функциональность регулярным выражениям.

В чём же разница между скобочными выражениями, и группирующими скобками?

<table>
	<tbody>
    <tr>
			<th>Группирующие скобки</th>
			<th>Скобочные выражения</th>
		</tr>
		<tr>
			<td>Не стоит символов, которые превращают их в скобочные выражения, или они экранированы.</td>
			<td>Стоят специальные символы после открывающейся круглой скобки.</td>
		</tr>
		<tr>
			<td>Создают группы, о которых можно будет получить более детальную информацию.</td>
			<td>Добавляют новый функционал регулярным выражениям.</td>
		</tr>
	</tbody>
</table>

# Non-capturing group, Comment group

## Comment group

(?#) - скобочное выражение, позволяющее написать комментарий в регулярном выражении

## Non-capturing group

(?:) - скобочное выражение, которое группирует регулярное выражение, но не захватывает его как скобочная группа. Так и называется - Non-capturing group, т.е. группа без захвата.

Его можно использовать, например, чтобы применять квантификаторы сразу к нескольким символам:

{% highlight r %}
(?:\d.){2} равносильно \d.\d.
{% endhighlight %}

Если бы мы использовали обычные группирующие скобки, они бы захватили эти символы отдельно.

Если вы используете группу, и не обращаетесь к ней по её имени/номеру - используйте вместо неё non-capturing group, так как обычные группы изменяют поведение методов в регулярных выражениях.

# Lookahead и Lookbehind

<table>
	<tbody>
    <tr>
			<th>Название</th>
			<th>Синтаксис</th>
      <th>Использование</th>
			<th>Пример</th>
      <th>Применяем к тексту</th>
		</tr>
		<tr>
			<td>Positive Lookahead</td>
			<td>(?=)</td>
      <td>Проверяет стоит ли переданное выражение после шаблона. Не захватывает никаких символов.</td>
			<td>2(?= 3)</td>
      <td>1 2 3 6 2 8</td>
		</tr>
		<tr>
			<td>Negative Lookahead</td>
			<td>(?!)</td>
      <td>Проверяет что переданное выражение не стоит после шаблона. Не захватывает никаких символов.</td>
			<td>2(?! 3)</td>
      <td>1 2 3 6 2 8</td>
		</tr>
    	<tr>
			<td>Positive Lookbehind</td>
			<td>(?<=)</td>
      <td>Проверяет стоит ли переданное выражение перед шаблоном. Не захватывает никаких символов.</td>
			<td>(?<=6 )2</td>
      <td>1 2 3 6 2 8</td>
		</tr>
		<tr>
			<td>Negative Lookbehind</td>
			<td>(?<!)</td>
      <td>Проверяет что переданное выражение не стоит перед шаблоном. Не захватывает никаких символов.</td>
			<td>(?<!6 )2</td>
      <td>1 2 3 6 2 8</td>
		</tr>
	</tbody>
</table>

# Условие (?(n)yes|no)

Есть интересное скобочное выражение, которое позволяет добавлять условия в регулярные выражения. Если у группы n нашлись совпадения - возвращается шаблон до |. В противном случае возвращается шаблон после |.

# Операция или

Синтаксис регулярных выражений позволяет писать такие выражения, которые найдут нужные строки при соответствии их хотя бы одному из выражений.

Например, выражение:

{% highlight r %}
r'Привет|Пока'
{% endhighlight %}

найдёт все слова Привет и Пока в тексте.

* Оператор или в скобочных выражениях и группах:
  
  Если использовать оператор или в скобочных выражениях или группах, то он не затронет символы извне.

* Оператор или в lookbehind
  
  Обратите внимание, что в lookbehind можно использовать (|), только если все шаблоны одинаковой длины. То есть такие выражения будут правильными:

{% highlight r %}
(?<=hi!|bye)
(?<![abcdef]|\d)
(?<=\w|\W|\s)
{% endhighlight %}

Такое использование lookbehind вызовет ошибку re.error: look-behind requires fixed-width pattern:

{% highlight r %}
(?<=hi!|long_text)
(?<![abcdef]|\d{4})
(?<=\w\s|\W)
{% endhighlight %}

Для того, чтобы обойти такое исключение, нужно использовать (|) в non-capturing group:

{% highlight r %}
(?:(?<=hi!)|(?<=long_text))
(?:(?<![abcdef])|(?<=\d{4}))
(?:(?<=\w\s)|(?<=\W))
{% endhighlight %}

В lookahead можно спокойно ставить условия с шаблонами разной длины, ошибок не будет.




