---
layout: post
title:  "Regex шпаргалка"
crawlertitle: "This is our first post"
summary: "Регулярные выражения"
date:   2020-06-20 23:09:47 +0700
categories: posts
tags: ['Веб аналитика']
#author: Felipe
---


Работая с Google Analytics, GTM или Datastudio, вы наверняка очень часто встречали слово «регулярное выражение». Регулярные выражения, сокращенно Regex , представляют собой специальные последовательности символов, которые помогают нам более эффективно работать с текстовыми значениями. Они используются при фильтрации, поиске, создании целей и сегментов.

Регулярное выражение - это последовательность символов, определяющая шаблон поиска, который затем сопоставляется с текстом. В веб-аналитике мы можем использовать регулярное выражение для поиска URL-адресов, текстовых шаблонов, названий событий, ключевых слов, источников трафика...

Чтобы лучше понять, что такое регулярные выражения, мы рассмотрим каждый специальный символ, объясним его значение и посмотрим на варианты использования.


# Вертикальная черта (\|)

Вертикальная черта - это наиболее часто используемая функция, которая вам понадобится для работы с Google Analytics. 

Значение этого выражения очень простое - оно означает « или ».

Если мы хотим отфильтровать данные только из Facebook или Google, мы просто напишем facebook \| google . Google Analytics выбирает либо одно, либо другое, либо и то, и другое.

[Пример на regexr](https://regexr.com/5g271)


# Точка (.)

Точка представляет любой символ. Ее еще часто называет wild card (англ. wild card, дословно — «дикая карта»).

Если мы определим шаблон поиска регулярного выражения как .от , он будет соответствовать словам мот, кот, пот, рот и т. Д. Однако регулярное выражение не будет соответствовать слову <b>от</b> (вместо точки должен быть символ).

Лучше всего использовать потенциал точки в сочетании с другими регулярными выражениями.

[Пример на regexr](https://regexr.com/5g26f)

# Звездочка (*)

Мы будем использовать звездочку, чтобы найти совпадения предыдущего элемента - он находит от 0 и более совподающих элементов .

В качестве примера возьмем google. К примеру если вы хотите найти все используемые словочетания google вы можете, использовать такое регулярное выражение go*gle, оно найдет все варианты gogle, google, gooogle, goooogle.

[Пример на regexr](https://regexr.com/5g2co)


 <!---
### Все регулярные выражения по группам

#### \*МОДИФИКАТОРЫ\*

{% highlight Ruby %}
«i" - регистронезависимость шаблона
"m" - расширенный режим привязки к границам строк. Модификатор включает режим работы шаблона с многострочным текстом
{% endhighlight %}

## \*МЕТАСИМВОЛЫ\*


«.» - точка соответствует любому символу, кроме перевода строки... внутри символьного класса трактуется как литерал

"\" - обратный слеш производит операцию экранирования метасимвола, следующего непосредственно за ним, тем самым последуюший метасимвол трактуется как литерал. Примеры: «.» (совпадение с любым символом), "\." (совпадаение только с точкой)

«[« - символ, открывающий символьный класс... если нужен в качестве литерала, то его необходимо экранировать

«]» - является метасимволом при наличии слева открывающей квадратной скобки... иначе - литерал, не требующий обязательного экранирования

«-« - в символьном классе между двумя символами (кроме символов символьного класса) является метасимволом и задает дипазон символов... иначе - литерал.

"^" - циркумфлекс, крышка. В начале символьного класса обозначает метасимвол отрицания, отрицающий все символы, указанные в символьном классе: «[^abc0-5]» - не "a", не "b", не "c" и не цифры от "0" до "5"... в любой другой позиции символьного класса циркумлекс будет литералом.

В начале шаблона крышка является метасимволом начала строки.

"$" - знак доллара. В конце шаблона знак доллара является метасимволом конца строки.

\b - граница слова

////////////////////////////////////////////////////
«Началом слова» считается та позиция, с которой начинается последовательность алфавитно-цифровых символов и символа подчеркивания
«Концом слова» считается позиция, в которой эта последовательность завершается.Граница слова обычно определяется как позиция, с одной стороны от которой находится «символ слова», а с другой – символ, не относящийся к этой категории.
Не граница слова - это позиция слева и справа от которой находятся либо символы не слова, либо символы слов
////////////////////////////////////////////////////

\B - не граница слова
«\t" - метасимвол табуляции
«\r" - возврат каретки
«\n" - новая строка
(…) - группа
a|b - оператор ИЛИ: «a» ИЛИ "b"

************************
*Символьные классы*
************************

«[abc]" - любой один символ из трех указанных: или "a", или "b", или "c"
«[a-f]" - символы в диапазоне от "a" до "f" (a,b,c,d,e,f)
«[0-9]» - цифры от "0" до "9" (0,1,2,3,4,5,6,7,8,9)

*************************************
*Метасимволы символьных классов*
*************************************

\d - [0-9], цифры
\D - [^0-9], кроме цифр
\w - [a-zA-Z0-9_], буквенно-цифровые символы и подчеркивание
\W - [^a-zA-Z0-9_], кроме буквенно-цифровых символов и подчеркивания
\s - [\r\n\t\f\v (пробел)], пробельные символы
\S - [^\r\n\t\f\v (пробел)], кроме пробельных символов

******************************
*Символьные классы POSIX*
******************************

[[:digit:]] - \d, [0-9]
[[:alnum:]] - [a-zA-Z0-9]
[[:alpha:]] - [a-zA-Z]
[[:blank:]] - пробел и табуляция
[[:lower:]] - [a-z]
[[:upper:]] - [A-Z]
[[:space:]] - \s
[[:xdigit:]] - [a-fA-F0-9]

************************
*КВАНТИФИКАТОРЫ*
************************

"+" - одно или более вхождений предшествующего элемента || min:1, max:не ограничено. Жадный квантификатор.
"*" - любое количество вхождений предшествующего элемента || min:0, max:не ограничено. Жадный квантификатор.
"?" - указывает на необязательность предшествующего элемента || min:0, max:1. Жадный квантификатор.
«{min,max}" - задает количество вхождений от значения min до значения max
«{min,}" - задает количество вхождений от значения min до бесконечности
«{точное количество}" - задает точное количество вхождений
Квантификаторы по умолчанию являются жадными, т.е. захватывают как можно больше вхождений. Добавляя к квантификатору знак вопроса, мы делаем его ленивым, т.е. заставляем искать как можно меньше вхождений.
«+?" - ленивый квантификатор
«*?" - ленивый квантификатор
«??" - ленивый квантификатор

***************************************
ПРОСМОТР ВПЕРЕД И НАЗАД
***************************************

(?=шаблон) - Позитивный просмотр вперед
(?!шаблон) - Негативный просмотр вперед 

(?<=шаблон) - Позитивный просмотр назад
(?<!шаблон) - Негативный просмотр назад
-->