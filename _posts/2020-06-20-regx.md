---
layout: post
title:  "Regex шпаргалка"
crawlertitle: "Основные операторы регулярных выражений"
summary: "Регулярные выражения"
date:   2020-06-20 23:09:47 +0700
categories: posts
tags: ['Веб аналитика']
#author: Felipe
---


Работая с Google Analytics, GTM или Datastudio, вы наверняка очень часто встречали слово «регулярное выражение». Регулярные выражения, сокращенно Regex, представляют собой специальные последовательности символов, которые помогают нам более эффективно работать с текстовыми значениями. Они используются при фильтрации, поиске, создании целей и сегментов.

Регулярное выражение — это последовательность символов, определяющая шаблон поиска, который затем сопоставляется с текстом. В веб-аналитике мы можем использовать регулярное выражение для поиска URL-адресов, текстовых шаблонов, названий событий, ключевых слов, источников трафика...

Чтобы лучше понять, что такое регулярные выражения, мы рассмотрим каждый специальный символ, объясним его значение и посмотрим на варианты использования.


# Вертикальная черта (|)

Вертикальная черта — это наиболее часто используемая функция, которая вам понадобится для работы с Google Analytics.

Значение этого выражения очень простое — оно означает « или ».

Если мы хотим отфильтровать данные только из Facebook или Google, мы просто напишем facebook (вертикальную черту по середине) google. Google Analytics выбирает либо одно, либо другое, либо и то, и другое.

[Пример на regexr](https://regexr.com/5g271)


# Точка (.)

Точка представляет любой символ. Ее еще часто называет wild card (англ. wild card, дословно — «дикая карта»).

Если мы определим шаблон поиска регулярного выражения как <b>.от</b>, он будет соответствовать словам мот, кот, пот, рот и т. Д. Однако регулярное выражение не будет соответствовать слову <b>от</b> (вместо точки должен быть символ).

Лучше всего использовать потенциал точки в сочетании с другими регулярными выражениями.

[Пример на regexr](https://regexr.com/5g26f)

# Звездочка (*)

Мы будем использовать звездочку, чтобы найти совпадения предыдущего элемента, она находит от 0 и более совпадающих элементов.

В качестве примера возьмем google. К примеру если вы хотите найти все используемые словосочетания google вы можете, использовать такое регулярное выражение go*gle, оно найдет все варианты gogle, google, gooogle, goooogle.

P.S. Звездочка срабатывает точно так же, как и знак плюс за исключением того, что она позволяет сопоставить НОЛЬ (или больше) из предыдущих элементов.

[Пример на regexr](https://regexr.com/5g2co)

# Точка - звездочка (. *)

Если мы хотим найти совпадение для любого символа, повторяющегося ноль или более раз, мы используем (. *). Точка означает “любой символ”, а следующая за ней звездочка означает может повторяться сколько угодно раз или вообще отсутствовать.

Пример: у вас есть несколько разных типов учетных записей клиентов, но вы хотите видеть свои данные для всех из них. Все они имеют похожие страницы, поэтому ваши страницы выглядят примерно так:

/customer/free/login/  
/customer/start/login/  
/customer/premium/login/  

Для этого вы можете написать следующее регулярное выражение:

/customer/.*/login

[Пример на regexr](https://regexr.com/5g3f8)
 
# Знак плюс (+)

Знак плюс (+) очень похож на *, за исключением того, что он соответствует ОДНОМУ или нескольким предыдущим символам. 

Пример: для слова hello + будет также найдено соответствие в hello, helloo, hellooo и т.д.

[Пример на regexr](https://regexr.com/5g3fn)

# Вопросительный знак (?)

Вопросительный знак означает, что предыдущий символ не требуется. Он может быть или не быть в слове.

Пример: у нас есть ключевое слово антенна, люди часто ошибаются и пишут его с одной буквой н - допустим мы хотим найти ключевое слово, в том числе с ошибкой.

Для этого вы можете написать следующее регулярное выражение:

антенн?а

И тогда вы получите оба ключевых слова, которые вы искали.

[Пример на regexr](https://regexr.com/5g3i8)

# Круглые скобки (())

Круглые скобки используются так же, как и в математике. Они помогают нам расставить приоритеты и изолировать логику, которая находится внутри них.

Пример:

2 × 5 + 10 = 20
2 × (5 + 10) = 30

Аналогичный принцип применяется к регулярным выражениям. Мы используем круглые скобки, чтобы сгруппировать различные части выражения вместе.

Допустим, у вас есть сайт с тремя предложениями, и вы хотите увидеть по этим трем предложениям страницы с ценами. 

Ваши URL-адреса следующие:

site.com/products/start/price  
site.com/products/premium/price  
site.com/products/vip/price  

Чтобы увидеть все предложения, вы можете использовать такое регулярное выражение:

\/products\/(start\|premium\|vip)\/price

[Пример на regexr](https://regexr.com/5g3j6)


# Квадратные скобки ([])

Квадратные скобки, внутри регулярного выражения, считаются одним символом «здесь должен быть один из перечисленных символов», который может принимать значения, перечисленные внутри этих скобок. 

Они подразделяются на наборы и диапазоны. 

Набор go[glo]gle для google сначала проверяет первую букву, потом вторую, потом третью.

[Пример на regexr](https://regexr.com/5g6au)

Диапазон к примеру, работает немного по другому он ищет по диапазону. Для регулярного выражения go[g-o]gle диапазон будет соответствовать символу в диапазоне от g до o, или на примере цифр [1-5] – цифра от 1 до 5.

[Пример на regexr](https://regexr.com/5g6bj)

# Тире (-)

Используется для создания расширенного списка. Чаще всего используется вместе со скобками для определения диапазона символов.

* [az] находит совпадение со всеми строчными буквами,
* [AZ] находит совпадение, состоящее только из прописных букв,
* [0-9] находит совпадение по всем цифрам,
* [a-zA-Z0-9] находит совпадение по всем строчным, прописным буквам и цифрам.

Пример:

Допустим вам нужно отфильтровать определенную группу товаров по моделям: 

MacBook Air 2017  
MacBook Air 2018  
MacBook Air 2019  
MacBook Air 2020  

[Пример на regexr](https://regexr.com/5g78r)

# Циркумфлекс (^)

^ (символ циркумфлекс, каретки) — в начале шаблона циркумфлекс является метасимволом начала строки.. В начале символьного класса обозначает метасимвол отрицания, отрицающий все символы, указанные в символьном классе: «[^abc0-5]» - не "a", не "b", не "c" и не цифры от "0" до "5"... в любой другой позиции символьного класса циркумлекс будет литералом.

Знак каретки '^' и доллара '$' имеют в регулярном выражении особый смысл. Их называют «якорями» (anchor – англ.).

[Пример начало на regexr](https://regexr.com/5g8fo)

[Пример отрицания на regexr](https://regexr.com/5g8g7)


# Знак доллара ($)

Знак доллара прямо противоположен знаку каретки - он позволяет находить строки, оканчивающиеся определенным сочетанием символов.

[Пример на regexr](https://regexr.com/5g8hb)

# Обратный слеш (\\)

”\\” - обратный слеш производит операцию экранирования метасимвола, следующего непосредственно за ним, тем самым последующий метасимвол трактуется как литерал. Примеры: «.» (совпадение с любым символом), “\\.” (совпадение только с точкой).

Например, если мы хотим отфильтровать только IP-адрес (67.172.171.105), мы должны экранировать точку, разделяющую отдельные числа: 
67\.172\.171\.105 - в этом случае регулярное выражение найдет IP 67.172.171.105.

Например нам нужно найти часть в URL-адресе nego/item?topicId=1994194356, если мы не будем использовать экранирование 
регулярное выражение будет воспринимать знак вопроса, как оператор регулярного выражения. 

[Пример на regexr](https://regexr.com/5g9iq)


# Фигурные скобки ({})

Фигурные скобки используются для указания конкретного количества повторений, от и до.

«{min,max}" - задает количество вхождений от значения min до значения max  
«{min,}" - задает количество вхождений от значения min до бесконечности  
«{точное количество}" - задает точное количество вхождений  

Проще всего понять на примере поиска IP адресов по маске. Чтобы найти соответствие в этом диапазоне IP-адресов от 77.120.120.0 до 
77.120.120.99, нам нужно написать следующее регулярное выражение: ^77\.120\.120\.[0–9]{1,2}$.

[Пример на regexr](https://regexr.com/5g9j6)

# Ленивый и жадный квантификатор

Квантификаторы (+, *, ?) по умолчанию являются жадными, т.е. захватывают как можно больше вхождений. Добавляя к квантификатору знак вопроса, мы делаем его ленивым, т.е. заставляем искать как можно меньше вхождений.

[Пример ленивый квантификатор](https://regexr.com/5g9jr)  
[Пример жадный квантификатор](https://regexr.com/5g9k4)  

# Символьные классы

«[abc]" - любой один символ из трех указанных: или "a", или "b", или "c"  
«[a-f]" - символы в диапазоне от "a" до "f" (a,b,c,d,e,f)  
«[0-9]» - цифры от "0" до "9" (0,1,2,3,4,5,6,7,8,9)  

# Метасимволы символьных классов

\d - [0-9], цифры  
\D - [^0-9], кроме цифр  
\w - [a-zA-Z0-9_], буквенно-цифровые символы и подчеркивание  
\W - [^a-zA-Z0-9_], кроме буквенно-цифровых символов и подчеркивания  
\s - [\r\n\t\f\v (пробел)], пробельные символы  
\S - [^\r\n\t\f\v (пробел)], кроме пробельных символов  




<!---

[Шпаргалка](https://ru.stackoverflow.com/questions/236947/%d0%a8%d0%bf%d0%b0%d1%80%d0%b3%d0%b0%d0%bb%d0%ba%d0%b0-%d0%bf%d0%be-%d1%80%d0%b5%d0%b3%d1%83%d0%bb%d1%8f%d1%80%d0%bd%d1%8b%d0%bc-%d0%b2%d1%8b%d1%80%d0%b0%d0%b6%d0%b5%d0%bd%d0%b8%d1%8f%d0%bc-php)

### Все регулярные выражения по группам

#### \*МОДИФИКАТОРЫ\*

{% highlight Ruby %}
«i" - регистронезависимость шаблона
"m" - расширенный режим привязки к границам строк. Модификатор включает режим работы шаблона с многострочным текстом
{% endhighlight %}

## \*МЕТАСИМВОЛЫ\*


«.» - точка соответствует любому символу, кроме перевода строки... внутри символьного класса трактуется как литерал

"\" - обратный слеш производит операцию экранирования метасимвола, следующего непосредственно за ним, тем самым последуюший метасимвол трактуется как литерал. Примеры: «.» (совпадение с любым символом), "\." (совпадаение только с точкой)

«[« - символ, открывающий символьный класс... если нужен в качестве литерала, то его необходимо экранировать

«]» - является метасимволом при наличии слева открывающей квадратной скобки... иначе - литерал, не требующий обязательного экранирования

«-« - в символьном классе между двумя символами (кроме символов символьного класса) является метасимволом и задает дипазон символов... иначе - литерал.

"^" - циркумфлекс, крышка. В начале символьного класса обозначает метасимвол отрицания, отрицающий все символы, указанные в символьном классе: «[^abc0-5]» - не "a", не "b", не "c" и не цифры от "0" до "5"... в любой другой позиции символьного класса циркумлекс будет литералом.

В начале шаблона крышка является метасимволом начала строки.

"$" - знак доллара. В конце шаблона знак доллара является метасимволом конца строки.

\b - граница слова

////////////////////////////////////////////////////
«Началом слова» считается та позиция, с которой начинается последовательность алфавитно-цифровых символов и символа подчеркивания
«Концом слова» считается позиция, в которой эта последовательность завершается.Граница слова обычно определяется как позиция, с одной стороны от которой находится «символ слова», а с другой – символ, не относящийся к этой категории.
Не граница слова - это позиция слева и справа от которой находятся либо символы не слова, либо символы слов
////////////////////////////////////////////////////

\B - не граница слова
«\t" - метасимвол табуляции
«\r" - возврат каретки
«\n" - новая строка
(…) - группа
a|b - оператор ИЛИ: «a» ИЛИ "b"

************************
*Символьные классы*
************************

«[abc]" - любой один символ из трех указанных: или "a", или "b", или "c"
«[a-f]" - символы в диапазоне от "a" до "f" (a,b,c,d,e,f)
«[0-9]» - цифры от "0" до "9" (0,1,2,3,4,5,6,7,8,9)

*************************************
*Метасимволы символьных классов*
*************************************

\d - [0-9], цифры
\D - [^0-9], кроме цифр
\w - [a-zA-Z0-9_], буквенно-цифровые символы и подчеркивание
\W - [^a-zA-Z0-9_], кроме буквенно-цифровых символов и подчеркивания
\s - [\r\n\t\f\v (пробел)], пробельные символы
\S - [^\r\n\t\f\v (пробел)], кроме пробельных символов

******************************
*Символьные классы POSIX*
******************************

[[:digit:]] - \d, [0-9]
[[:alnum:]] - [a-zA-Z0-9]
[[:alpha:]] - [a-zA-Z]
[[:blank:]] - пробел и табуляция
[[:lower:]] - [a-z]
[[:upper:]] - [A-Z]
[[:space:]] - \s
[[:xdigit:]] - [a-fA-F0-9]

************************
*КВАНТИФИКАТОРЫ*
************************

"+" - одно или более вхождений предшествующего элемента || min:1, max:не ограничено. Жадный квантификатор.
"*" - любое количество вхождений предшествующего элемента || min:0, max:не ограничено. Жадный квантификатор.
"?" - указывает на необязательность предшествующего элемента || min:0, max:1. Жадный квантификатор.
«{min,max}" - задает количество вхождений от значения min до значения max
«{min,}" - задает количество вхождений от значения min до бесконечности
«{точное количество}" - задает точное количество вхождений
Квантификаторы по умолчанию являются жадными, т.е. захватывают как можно больше вхождений. Добавляя к квантификатору знак вопроса, мы делаем его ленивым, т.е. заставляем искать как можно меньше вхождений.
«+?" - ленивый квантификатор
«*?" - ленивый квантификатор
«??" - ленивый квантификатор

***************************************
ПРОСМОТР ВПЕРЕД И НАЗАД
***************************************

(?=шаблон) - Позитивный просмотр вперед
(?!шаблон) - Негативный просмотр вперед 

(?<=шаблон) - Позитивный просмотр назад
(?<!шаблон) - Негативный просмотр назад
-->