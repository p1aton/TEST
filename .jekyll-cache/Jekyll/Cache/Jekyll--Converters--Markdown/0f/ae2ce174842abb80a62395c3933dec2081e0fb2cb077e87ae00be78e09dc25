I"H[<p>Работая с Google Analytics, GTM или Datastudio, вы наверняка очень часто встречали слово «регулярное выражение». Регулярные выражения, сокращенно Regex, представляют собой специальные последовательности символов, которые помогают нам более эффективно работать с текстовыми значениями. Они используются при фильтрации, поиске, создании целей и сегментов.</p>

<p>Регулярное выражение — это последовательность символов, определяющая шаблон поиска, который затем сопоставляется с текстом. В веб-аналитике мы можем использовать регулярное выражение для поиска URL-адресов, текстовых шаблонов, названий событий, ключевых слов, источников трафика…</p>

<p>Чтобы лучше понять, что такое регулярные выражения, мы рассмотрим каждый специальный символ, объясним его значение и посмотрим на варианты использования.</p>

<h1 id="вертикальная-черта-">Вертикальная черта (|)</h1>

<p>Вертикальная черта — это наиболее часто используемая функция, которая вам понадобится для работы с Google Analytics.</p>

<p>Значение этого выражения очень простое — оно означает « или ».</p>

<table>
  <tbody>
    <tr>
      <td>Если мы хотим отфильтровать данные только из Facebook или Google, мы просто напишем facebook</td>
      <td>google. Google Analytics выбирает либо одно, либо другое, либо и то, и другое.</td>
    </tr>
  </tbody>
</table>

<p><a href="https://regexr.com/5g271">Пример на regexr</a></p>

<h1 id="точка-">Точка (.)</h1>

<p>Точка представляет любой символ. Ее еще часто называет wild card (англ. wild card, дословно — «дикая карта»).</p>

<p>Если мы определим шаблон поиска регулярного выражения как <b>.от</b>, он будет соответствовать словам мот, кот, пот, рот и т. Д. Однако регулярное выражение не будет соответствовать слову <b>от</b> (вместо точки должен быть символ).</p>

<p>Лучше всего использовать потенциал точки в сочетании с другими регулярными выражениями.</p>

<p><a href="https://regexr.com/5g26f">Пример на regexr</a></p>

<h1 id="звездочка-">Звездочка (*)</h1>

<p>Мы будем использовать звездочку, чтобы найти совпадения предыдущего элемента, она находит от 0 и более совпадающих элементов.</p>

<p>В качестве примера возьмем google. К примеру если вы хотите найти все используемые словосочетания google вы можете, использовать такое регулярное выражение go*gle, оно найдет все варианты gogle, google, gooogle, goooogle.</p>

<p>P.S. Звездочка срабатывает точно так же, как и знак плюс за исключением того, что она позволяет сопоставить НОЛЬ (или больше) из предыдущих элементов.</p>

<p><a href="https://regexr.com/5g2co">Пример на regexr</a></p>

<h1 id="точка---звездочка--">Точка - звездочка (. *)</h1>

<p>Если мы хотим найти совпадение для любого символа, повторяющегося ноль или более раз, мы используем (. *). Точка означает “любой символ”, а следующая за ней звездочка означает может повторяться сколько угодно раз или вообще отсутствовать.</p>

<p>Пример: у вас есть несколько разных типов учетных записей клиентов, но вы хотите видеть свои данные для всех из них. Все они имеют похожие страницы, поэтому ваши страницы выглядят примерно так:</p>

<p>/customer/free/login/<br />
/customer/start/login/<br />
/customer/premium/login/</p>

<p>Для этого вы можете написать следующее регулярное выражение:</p>

<p>/customer/.*/login</p>

<p><a href="https://regexr.com/5g3f8">Пример на regexr</a></p>

<h1 id="знак-плюс-">Знак плюс (+)</h1>

<p>Знак плюс (+) очень похож на *, за исключением того, что он соответствует ОДНОМУ или нескольким предыдущим символам.</p>

<p>Пример: для слова hello + будет также найдено соответствие в hello, helloo, hellooo и т.д.</p>

<p><a href="https://regexr.com/5g3fn">Пример на regexr</a></p>

<h1 id="вопросительный-знак-">Вопросительный знак (?)</h1>

<p>Вопросительный знак означает, что предыдущий символ не требуется. Он может быть или не быть в слове.</p>

<p>Пример: у нас есть ключевое слово антенна, люди часто ошибаются и пишут его с одной буквой н - допустим мы хотим найти ключевое слово, в том числе с ошибкой.</p>

<p>Для этого вы можете написать следующее регулярное выражение:</p>

<p>антенн?а</p>

<p>И тогда вы получите оба ключевых слова, которые вы искали.</p>

<p><a href="https://regexr.com/5g3i8">Пример на regexr</a></p>

<h1 id="круглые-скобки-">Круглые скобки (())</h1>

<p>Круглые скобки используются так же, как и в математике. Они помогают нам расставить приоритеты и изолировать логику, которая находится внутри них.</p>

<p>Пример:</p>

<p>2 × 5 + 10 = 20
2 × (5 + 10) = 30</p>

<p>Аналогичный принцип применяется к регулярным выражениям. Мы используем круглые скобки, чтобы сгруппировать различные части выражения вместе.</p>

<p>Допустим, у вас есть сайт с тремя предложениями, и вы хотите увидеть по этим трем предложениям страницы с ценами.</p>

<p>Ваши URL-адреса следующие:</p>

<p>site.com/products/start/price<br />
site.com/products/premium/price<br />
site.com/products/vip/price</p>

<p>Чтобы увидеть все предложения, вы можете использовать такое регулярное выражение:</p>

<p>\/products\/(start|premium|vip)\/price</p>

<p><a href="https://regexr.com/5g3j6">Пример на regexr</a></p>

<h1 id="квадратные-скобки-">Квадратные скобки ([])</h1>

<p>Квадратные скобки, внутри регулярного выражения, считаются одним символом «здесь должен быть один из перечисленных символов», который может принимать значения, перечисленные внутри этих скобок.</p>

<p>Они подразделяются на наборы и диапазоны.</p>

<p>Набор go[glo]gle для google сначала проверяет первую букву, потом вторую, потом третью.</p>

<p><a href="https://regexr.com/5g6au">Пример на regexr</a></p>

<p>Диапазон к примеру, работает немного по другому он ищет по диапазону. Для регулярного выражения go[g-o]gle диапазон будет соответствовать символу в диапазоне от g до o, или на примере цифр [1-5] – цифра от 1 до 5.</p>

<p><a href="https://regexr.com/5g6bj">Пример на regexr</a></p>

<h1 id="тире--">Тире (-)</h1>

<p>Используется для создания расширенного списка. Чаще всего используется вместе со скобками для определения диапазона символов.</p>

<ul>
  <li>[az] находит совпадение со всеми строчными буквами,</li>
  <li>[AZ] находит совпадение, состоящее только из прописных букв,</li>
  <li>[0-9] находит совпадение по всем цифрам,</li>
  <li>[a-zA-Z0-9] находит совпадение по всем строчным, прописным буквам и цифрам.</li>
</ul>

<p>Пример:</p>

<p>Допустим вам нужно отфильтровать определенную группу товаров по моделям:</p>

<p>MacBook Air 2017<br />
MacBook Air 2018<br />
MacBook Air 2019<br />
MacBook Air 2020</p>

<p><a href="https://regexr.com/5g78r">Пример на regexr</a></p>

<h1 id="циркумфлекс-">Циркумфлекс (^)</h1>

<p>^ (символ циркумфлекс, каретки) — в начале шаблона циркумфлекс является метасимволом начала строки.. В начале символьного класса обозначает метасимвол отрицания, отрицающий все символы, указанные в символьном классе: «[^abc0-5]» - не “a”, не “b”, не “c” и не цифры от “0” до “5”… в любой другой позиции символьного класса циркумлекс будет литералом.</p>

<p>Знак каретки ‘^’ и доллара ‘$’ имеют в регулярном выражении особый смысл. Их называют «якорями» (anchor – англ.).</p>

<p><a href="https://regexr.com/5g8fo">Пример начало на regexr</a></p>

<p><a href="https://regexr.com/5g8g7">Пример отрицания на regexr</a></p>

<h1 id="знак-доллара-">Знак доллара ($)</h1>

<p>Знак доллара прямо противоположен знаку каретки - он позволяет находить строки, оканчивающиеся определенным сочетанием символов.</p>

<p><a href="https://regexr.com/5g8hb">Пример на regexr</a></p>

<h1 id="обратный-слеш-">Обратный слеш (\)</h1>

<p>”\” - обратный слеш производит операцию экранирования метасимвола, следующего непосредственно за ним, тем самым последующий метасимвол трактуется как литерал. Примеры: «.» (совпадение с любым символом), “\.” (совпадение только с точкой).</p>

<p>Например, если мы хотим отфильтровать только IP-адрес (67.172.171.105), мы должны экранировать точку, разделяющую отдельные числа: 
67.172.171.105 - в этом случае регулярное выражение найдет IP 67.172.171.105.</p>

<p>Например нам нужно найти часть в URL-адресе nego/item?topicId=1994194356, если мы не будем использовать экранирование 
регулярное выражение будет воспринимать знак вопроса, как оператор регулярного выражения.</p>

<p><a href="https://regexr.com/5g9iq">Пример на regexr</a></p>

<h1 id="фигурные-скобки-">Фигурные скобки ({})</h1>

<p>Фигурные скобки используются для указания конкретного количества повторений, от и до.</p>

<p>«{min,max}” - задает количество вхождений от значения min до значения max<br />
«{min,}” - задает количество вхождений от значения min до бесконечности<br />
«{точное количество}” - задает точное количество вхождений</p>

<p>Проще всего понять на примере поиска IP адресов по маске. Чтобы найти соответствие в этом диапазоне IP-адресов от 77.120.120.0 до 
77.120.120.99, нам нужно написать следующее регулярное выражение: ^77.120.120.[0–9]{1,2}$.</p>

<p><a href="https://regexr.com/5g9j6">Пример на regexr</a></p>

<h1 id="ленивый-и-жадный-квантификатор">Ленивый и жадный квантификатор</h1>

<p>Квантификаторы (+, *, ?) по умолчанию являются жадными, т.е. захватывают как можно больше вхождений. Добавляя к квантификатору знак вопроса, мы делаем его ленивым, т.е. заставляем искать как можно меньше вхождений.</p>

<p><a href="https://regexr.com/5g9jr">Пример ленивый квантификатор</a><br />
<a href="https://regexr.com/5g9k4">Пример жадный квантификатор</a></p>

<h1 id="символьные-классы">Символьные классы</h1>

<p>«[abc]” - любой один символ из трех указанных: или “a”, или “b”, или “c”<br />
«[a-f]” - символы в диапазоне от “a” до “f” (a,b,c,d,e,f)<br />
«[0-9]» - цифры от “0” до “9” (0,1,2,3,4,5,6,7,8,9)</p>

<h1 id="метасимволы-символьных-классов">Метасимволы символьных классов</h1>

<p>\d - [0-9], цифры<br />
\D - [^0-9], кроме цифр<br />
\w - [a-zA-Z0-9_], буквенно-цифровые символы и подчеркивание<br />
\W - [^a-zA-Z0-9_], кроме буквенно-цифровых символов и подчеркивания<br />
\s - [\r\n\t\f\v (пробел)], пробельные символы<br />
\S - [^\r\n\t\f\v (пробел)], кроме пробельных символов</p>

<!---

[Шпаргалка](https://ru.stackoverflow.com/questions/236947/%d0%a8%d0%bf%d0%b0%d1%80%d0%b3%d0%b0%d0%bb%d0%ba%d0%b0-%d0%bf%d0%be-%d1%80%d0%b5%d0%b3%d1%83%d0%bb%d1%8f%d1%80%d0%bd%d1%8b%d0%bc-%d0%b2%d1%8b%d1%80%d0%b0%d0%b6%d0%b5%d0%bd%d0%b8%d1%8f%d0%bc-php)

### Все регулярные выражения по группам

#### \*МОДИФИКАТОРЫ\*


<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="err">«</span><span class="n">i</span><span class="s2">" - регистронезависимость шаблона
"</span><span class="n">m</span><span class="s2">" - расширенный режим привязки к границам строк. Модификатор включает режим работы шаблона с многострочным текстом</span></code></pre></figure>


## \*МЕТАСИМВОЛЫ\*


«.» - точка соответствует любому символу, кроме перевода строки... внутри символьного класса трактуется как литерал

"\" - обратный слеш производит операцию экранирования метасимвола, следующего непосредственно за ним, тем самым последуюший метасимвол трактуется как литерал. Примеры: «.» (совпадение с любым символом), "\." (совпадаение только с точкой)

«[« - символ, открывающий символьный класс... если нужен в качестве литерала, то его необходимо экранировать

«]» - является метасимволом при наличии слева открывающей квадратной скобки... иначе - литерал, не требующий обязательного экранирования

«-« - в символьном классе между двумя символами (кроме символов символьного класса) является метасимволом и задает дипазон символов... иначе - литерал.

"^" - циркумфлекс, крышка. В начале символьного класса обозначает метасимвол отрицания, отрицающий все символы, указанные в символьном классе: «[^abc0-5]» - не "a", не "b", не "c" и не цифры от "0" до "5"... в любой другой позиции символьного класса циркумлекс будет литералом.

В начале шаблона крышка является метасимволом начала строки.

"$" - знак доллара. В конце шаблона знак доллара является метасимволом конца строки.

\b - граница слова

////////////////////////////////////////////////////
«Началом слова» считается та позиция, с которой начинается последовательность алфавитно-цифровых символов и символа подчеркивания
«Концом слова» считается позиция, в которой эта последовательность завершается.Граница слова обычно определяется как позиция, с одной стороны от которой находится «символ слова», а с другой – символ, не относящийся к этой категории.
Не граница слова - это позиция слева и справа от которой находятся либо символы не слова, либо символы слов
////////////////////////////////////////////////////

\B - не граница слова
«\t" - метасимвол табуляции
«\r" - возврат каретки
«\n" - новая строка
(…) - группа
a|b - оператор ИЛИ: «a» ИЛИ "b"

************************
*Символьные классы*
************************

«[abc]" - любой один символ из трех указанных: или "a", или "b", или "c"
«[a-f]" - символы в диапазоне от "a" до "f" (a,b,c,d,e,f)
«[0-9]» - цифры от "0" до "9" (0,1,2,3,4,5,6,7,8,9)

*************************************
*Метасимволы символьных классов*
*************************************

\d - [0-9], цифры
\D - [^0-9], кроме цифр
\w - [a-zA-Z0-9_], буквенно-цифровые символы и подчеркивание
\W - [^a-zA-Z0-9_], кроме буквенно-цифровых символов и подчеркивания
\s - [\r\n\t\f\v (пробел)], пробельные символы
\S - [^\r\n\t\f\v (пробел)], кроме пробельных символов

******************************
*Символьные классы POSIX*
******************************

[[:digit:]] - \d, [0-9]
[[:alnum:]] - [a-zA-Z0-9]
[[:alpha:]] - [a-zA-Z]
[[:blank:]] - пробел и табуляция
[[:lower:]] - [a-z]
[[:upper:]] - [A-Z]
[[:space:]] - \s
[[:xdigit:]] - [a-fA-F0-9]

************************
*КВАНТИФИКАТОРЫ*
************************

"+" - одно или более вхождений предшествующего элемента || min:1, max:не ограничено. Жадный квантификатор.
"*" - любое количество вхождений предшествующего элемента || min:0, max:не ограничено. Жадный квантификатор.
"?" - указывает на необязательность предшествующего элемента || min:0, max:1. Жадный квантификатор.
«{min,max}" - задает количество вхождений от значения min до значения max
«{min,}" - задает количество вхождений от значения min до бесконечности
«{точное количество}" - задает точное количество вхождений
Квантификаторы по умолчанию являются жадными, т.е. захватывают как можно больше вхождений. Добавляя к квантификатору знак вопроса, мы делаем его ленивым, т.е. заставляем искать как можно меньше вхождений.
«+?" - ленивый квантификатор
«*?" - ленивый квантификатор
«??" - ленивый квантификатор

***************************************
ПРОСМОТР ВПЕРЕД И НАЗАД
***************************************

(?=шаблон) - Позитивный просмотр вперед
(?!шаблон) - Негативный просмотр вперед 

(?<=шаблон) - Позитивный просмотр назад
(?<!шаблон) - Негативный просмотр назад
-->
:ET